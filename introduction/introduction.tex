
\chapter{Introduction}

\section{Motivation}

\todo[inline]{Importance of real-time system. Elaborate...}
Real-time systems enforce stringent timing constraints. 
Such systems have a continuous interaction with the environment and the timing of outputs in response to events in the environment is important. 
A timing bound is normally referred to as a deadline. 
A real-time system is one whose correctness is based on both the correctness of the outputs and their timeliness.
A real-time system does not have to be fast: the deadline may be days or weeks.

\begin{myDef}
A real-time system is one that must process information and produce a response within a specified time, else risk severe consequences, including failure.
\end{myDef}

\begin{myDef}
Any system in which the time at which output is produced is significant.
This is usually because the input corresponds to some event in the physical world, and the output has to relate to that same event.
The lag from input time to output time must be sufficiently small for acceptable timeliness.(Oxford Dictionary of Computing)
\end{myDef}

\begin{myDef}
Soft real-time systems: In a lose approach all practical systems can be said to be real-time systems because they must produce an output or response to the user's commands within a reasonable amount of time.
These systems where uncomfortably long response times are a nuisance but the system still functions even if deadlines are sometimes not met are called soft real-time systems.
\end{myDef}

\begin{myDef}
Hard real-time systems: Systems where failure to meet response time constraints leads to catastrophic system failure (aircraft crashing, car skidding, patient dying) are called hard real-time systems.
\end{myDef}

\begin{myDef}
Failure: inability to perform according to specification.
In the case of real-time systems the "failed" specification may be lack of correctness or the failure to produce the response by the required time.
\end{myDef}

For instance, ......



\todo[inline]{Examples of real-time system. Elaborate...}
Real-time systems are abundant in daily applications, including air traffic management~\cite{crisostomi07,eele11}, unmanned aerial vehicles~\cite{ortiz06}, ABS, robotics~\cite{dellaert99}, medical surgery~\cite{kwok10}, over-temperature monitor in nuclear power station, etc.

\todo[inline]{Properties of real-time system. Elaborate...}
Real-time systems can be classified into two types. Hard real-time systems should response to events within fixed time. Missing an operation deadline can cause a total system failure. In soft real-time systems, exact response time is not critical but missing an operation deadline can cause degraded quality of service. In general, real-time systems desire the following properties:

\begin{itemize}
\item Timeliness: output values are produced before the deadlines.
\item Robustness: the system should work when subject to a peak load.
\item Predictability: the system behavior is known before it is put into operation.
%\item Testability: the system can be tested whether it can meet all deadlines.
\end{itemize}

\todo[inline]{Explain current problems and challenges.}

Over the previous decades, a proliferation of work focuses on design and analysis of real-time systems. There are challenges in a number of disciplines, such as hardware architectures, operating systems, scheduling theories, analysis and design tools, and programming languages. Nowadays, the arise of reconfigurable system and massive parallel processing units, such as \gls{fpga}, provide new opportunities to address the challenges of real-time systems. Exploiting the reconfigurability and parallelism of \gls{fpga} could improve design and analysis of applications in the real-time domain.

On the other hand, verification of real-time system is a major concern. Many high performance real-time applications require tight response time, and measurement precision has increased to microsecond level. For example, high-frequency trading is becoming popular with execution time bounded to microseconds~\cite{mcgowan10}. However, traditional execution time analysis techniques such as profiling are subject to precision problem. For software, there is gprof to analyze where a program spent its execution time on. Some system calls allow obtaining system time for execution time measurement. However, due to factors such as compiler support and interrupt of I/Os, these measurement techniques significantly degrade system performance, having precision at most in milliseconds.  Despite simulation of system at register-transfer-level can provide cycle-accurate information, simulation cannot scale well since technology advances are making real-time systems more complex~\cite{stankovic88}. Distributed computing and multiprocessing complicate task, resource and communication scheduling. Static analysis and design methods are often infeasible for ensuring correctness of systems within deployed environment. Running benchmark on a deployed system provides an additional level of confidence as some defects cannot be discovered before deployment.

The major objectives of this research are:

\begin{enumerate}
\item \textit{To study adaptive real-time systems}: Under real-time scenarios, the challenges turn out to be achieving timeliness, robustness and predictability. Rather than optimising throughput, real-time design could achieve energy reduction, better resource usage and improved quality of results within the deadlines. Based on run-time variation of environment and quality of results, a reconfigurable real-time system can adapt its hardware, software and algorithm for optimised performance, resource usage and power consumption. Dynamic workload and resource scheduling, frequency and voltage scaling, run-time reconfiguration are examples of adaptive techniques that could be employed.
\item \textit{To explore facilities for evaluating real-time performance}: A benchmarking platform will be developed to evaluate real-time systems. The evaluation focuses on requirements specific to real-time designs, such as the ability of a system to keep accurate time and perform predictably and deterministically. A set of benchmark applications, each of which consists of algorithm and test data, will be used by the benchmarking platform.
\item \textit{To investigate adaptive real-time applications}: Real-time applications will be developed using the adaptive approach and they will be evaluated using the benchmarking platform.
\end{enumerate}


\section{Research Challenges and Contributions}

\todo[inline]{Propose solutions using reconfigurable systems. Justify why moving demanding applications to FPGA.}

To summarise, XXXXXXXXX has been developed, with the following contributions.

\begin{itemize}
\item Precision optimisation: Maximise processing power, i.e. more computation, better accuracy within the real-time window. \todo[inline]{More description.}
\item Run-time reconfiguration: Use time slack in the real-time window, reconfigure to low-power mode to reduce power consumption. \todo[inline]{More description.}
\item Design productivity: Maximise accuracy without violating real-time constraint, minimise design effort. \todo[inline]{More description.} 
\end{itemize}

\todo[inline]{Describe target applications:
Image guidance for medical surgery robot (proximity query).
Mobile robot localisation (SMC methods).
Air traffic management (SMC methods).
Stochastic volatility (SMC methods, small).
}

\todo[inline]{Relate chapters to real-time properties: timeliness, robustness, predictability.}

Figure~\ref{fig:contributions} provides a relationship diagram of each chapter in the thesis.
Each block corresponds to a chapter in the thesis.
\todo[inline]{How are they connected to each other?}

Chapter~\ref{ch:background} offers a comprehensive literature review of related work.
This chapter describes background information about real-time systems and identifies current challenges.

Chapter~\ref{ch:precision} demonstrates how functional transformation and reduced precision methodologies are applied to reconfigurable systems.
A Proximity Query (PQ) formulation is derived to support non-convex objects represented by meshes or cloud points. 
This chapter corresponds to Contribute A and it addresses one of the important challenges in this thesis - XXXXXXXXXXXXXX.

Chapter~\ref{ch:run-time} presents an approach for mapping real-time applications to heterogeneous reconfigurable systems with run-time reconfigurability.
An adaptive sequential Monte Carlo (SMC) method is proposed to utilise run-time reconfigurability of FPGAs for reduced power and energy consumption. 
A data compression scheme is employed to reduce communication overhead between FPGAs and CPUs.
This chapter corresponds to Contribute B and it is XXXXXXXXXXXXXX.

Chapter~\ref{ch:flow} describes a design flow for generating efficient implementation of reconfigurable SMC designs. 
Through templating the SMC structure, the design flow enables efficient mapping of SMC applications to multiple FPGAs.
The proposed design flow consists of a parametrisable SMC computation engine, and an open-source software template which enables efficient mapping of a variety of SMC designs to reconfigurable hardware.
Design parameters that are critical to the performance and to the solution quality are tuned using a machine learning algorithm based on surrogate modelling.
The chapter corresponds to Contribution C ...

Conclusion of the thesis and suggestions for future work are made in Chapter~\ref{ch:conclusion}.

\section{Statement of Originality}

I declare that this thesis was composed by myself, and that the work it presents is my own, except where otherwise stated.

